# SPDX-License-Identifier: Apache-2.0
# Copyright 2019 Intel Corporation
# Copyright 2020 Open Networking Foundation
# ---
# apiVersion: "k8s.cni.cncf.io/v1"
# kind: NetworkAttachmentDefinition
# metadata:
#   name: access-net
#   annotations:
#     k8s.v1.cni.cncf.io/resourceName: intel.com/sriov_vfio_access_net
# spec:
#   config: '{
#     "cniVersion": "0.3.1",
#     "type": "vfioveth",
#     "name": "access-net",
#     "ipam": {
#         "type": "host-local",
#         "subnet": "198.18.0.0/24",
#         "rangeStart": "198.18.0.2",
#         "rangeEnd": "198.18.0.250",
#         "gateway": "198.18.0.1"
#     }}'
# ---
# apiVersion: "k8s.cni.cncf.io/v1"
# kind: NetworkAttachmentDefinition
# metadata:
#   name: core-net
#   annotations:
#     k8s.v1.cni.cncf.io/resourceName: intel.com/sriov_vfio_core_net
# spec:
#   config: '{
#     "cniVersion": "0.3.1",
#     "type": "vfioveth",
#     "name": "core-net",
#     "ipam": {
#         "type": "host-local",
#         "subnet": "198.19.0.0/24",
#         "rangeStart": "198.19.0.2",
#         "rangeEnd": "198.19.0.250",
#         "gateway": "198.19.0.1"
#     }}'
# ---
apiVersion: v1
kind: ConfigMap
metadata:
  name: upf-conf
data:
  upf.json: |
    {
    "": "Vdev or sim support. Enable `\"mode\": \"af_xdp\"` to enable AF_XDP mode, or `\"mode\": \"af_packet\"` to enable AF_PACKET mode, or `\"mode\": \"sim\"` to generate synthetic traffic from BESS's Source module",
    "": "mode: af_xdp",
    "": "mode: af_packet",
    "": "mode: sim",
    "mode": "dpdk",

    "": "max UE sessions",
    "max_sessions": 50000,

    "": "Set the log level to one of \"panic\", \"fatal\", \"error\", \"warning\", \"info\", \"debug\", \"trace\"",
    "log_level": "info",

    "": "Use the sim block to enable simulation using either Source module or via il_trafficgen",
    "sim": {
        "": "At this point we can simulate either N3/N6 or N3/N9 traffic, so choose n6 or n9 below",
        "core": "n6",
        "start_ue_ip": "16.0.0.1",
        "start_enb_ip": "11.1.1.129",
        "start_aupf_ip": "13.1.1.199",
        "n6_app_ip": "6.6.6.6",
        "n9_app_ip": "9.9.9.9",
        "start_n3_teid": "0x30000000",
        "start_n9_teid": "0x90000000",
        "pkt_size": 128,
        "total_flows": 100
    },

    "": "max IP frag table entries (for IPv4 reassembly). Update the line below to `\"max_ip_defrag_flows\": 1000` to enable",
    "": "max_ip_defrag_flows: 1000",

    "": "Update the line below to `\"ip_frag_with_eth_mtu\": 1518` to enable",
    "": "ip_frag_with_eth_mtu: 1518",

    "": "Enable hardware offload of checksum. Might disable vector PMD",
    "hwcksum": false,

    "": "Enable PDU Session Container extension",
    "gtppsc": false,

    "": "Enable Intel Dynamic Device Personalization (DDP)",
    "ddp": false,

    "": "Telemetrics-See this link for details: https://github.com/NetSys/bess/blob/master/bessctl/module_tests/timestamp.py",
    "measure": true,

    "": "Gateway interfaces",
    "access": {
        "ifname": "ens1f0",
        "pci": "0000:3b:02.1"
    },

    "": "UE IP Natting. Update the line below to `\"ip_masquerade\": \"<ip> [or <ip>]\"` to enable",
    "core": {
        "ifname": "ens1f1",
        "pci": "0000:3b:0a.1",
        "": "ip_masquerade: 18.0.0.1 or 18.0.0.2 or 18.0.0.3"
    },

    "": "Number of worker threads. Default: 1",
    "workers": 14,

    "": "Whether to enable Network Token Functions",
    "enable_ntf": false,

    "": "Whether to enable End Marker Support",
    "": "enable_end_marker: false",

    "": "Whether to enable Notify BESS feature",
    "": "enable_notify_bess: false",

    "": "Whether to enable P4Runtime feature",
    "enable_p4rt": false,
    "" : "conn_timeout: 1000",
    "" : "read_timeout: 25",
    "notify_sockaddr": "/tmp/notifycp2",
    "endmarker_sockaddr": "/tmp/pfcpport2",

    "qci_qos_config": [
        {
            "qci": 9,
            "cbs": 2048,
            "ebs": 2048,
            "pbs": 2048,
            "priority": 6
        },
        {
            "qci": 8,
            "cbs": 2048,
            "ebs": 2048,
            "pbs": 2048,
            "priority": 5
        }
    ],
    "": "Control plane controller settings",
    "cpiface": {
        "enable_ue_ip_alloc": false,
        "ue_ip_pool": "10.250.0.0/16",
        "" : "nb_dst_ip: CPHostname",
        "" : "hostname: upf",
        "prom_port": "8082",
        "" : "dnn:internet"
    },

    "": "p4rtc interface settings",
    "p4rtciface": {
    "access_ip": "172.17.0.1/32",
    "p4rtc_server": "onos",
    "p4rtc_port": "51001",
    "ue_ip_pool": "10.250.0.0/24"
    }}
  route_control_normal.py: |
    #!/usr/bin/env python
    # SPDX-License-Identifier: Apache-2.0
    # Copyright(c) 2019 Intel Corporation

    import argparse
    import signal
    import sys
    import time

    # for retrieving neighbor info
    from pyroute2 import IPDB, IPRoute

    from scapy.all import *

    try:
        from pybess.bess import *
    except ImportError:
        print('Cannot import the API module (pybess)')
        raise

    MAX_RETRIES = 5
    SLEEP_S = 2


    class NeighborEntry:
        def __init__(self):
            self.neighbor_ip = None
            self.iface = None
            self.iprange = None
            self.prefix_len = None
            self.route_count = 0
            self.gate_idx = 0
            self.macstr = None

        def __str__(self):
            return ('{neigh: %s, iface: %s, ip-range: %s/%s}' %
                    (self.neighbor_ip, self.iface, self.iprange, self.prefix_len))


    def mac2hex(mac):
        return int(mac.replace(':', ''), 16)


    def send_ping(neighbor_ip):
        send(IP(dst=neighbor_ip) / ICMP())


    def send_arp(neighbor_ip, src_mac, iface):
        pkt = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=neighbor_ip, hwsrc=src_mac)
        pkt.show()
        hexdump(pkt)
        sendp(pkt, iface=iface)


    def fetch_mac(dip):
        ip = ''
        _mac = ''
        neighbors = ipr.get_neighbours(dst=dip)
        for i in range(len(neighbors)):
            for att in neighbors[i]['attrs']:
                if 'NDA_DST' in att and dip == att[1]:
                    # ('NDA_DST', dip)
                    ip = att[1]
                if 'NDA_LLADDR' in att:
                    # ('NDA_LLADDR', _mac)
                    _mac = att[1]
                    return _mac


    def link_modules(server, module, next_module, ogate=0, igate=0):
        print('Linking {} module'.format(next_module))

        # Pause bess first
        bess.pause_all()
        # Connect module to next_module
        for _ in range(MAX_RETRIES):
            try:
                server.connect_modules(module, next_module, ogate, igate)
            except BESS.Error as e:
                bess.resume_all()
                if e.code == errno.EBUSY:
                    break
                else:
                    return  #raise
            except Exception as e:
                print(
                    'Error connecting module {}:{}->{}:{}: {}. Retrying in {} secs...'
                    .format(module, ogate, igate, next_module, e, SLEEP_S))
                time.sleep(SLEEP_S)
            else:
                bess.resume_all()
                break
        else:
            bess.resume_all()
            print('BESS module connection ({}:{}->{}:{}) failure.'.format(
                module, ogate, igate, next_module))
            return
            #raise Exception('BESS module connection ({}:{}->{}:{}) failure.'.
            #                format(module, ogate, igate, next_module))


    def link_route_module(server, gateway_mac, item):
        iprange = item.iprange
        prefix_len = item.prefix_len
        route_module = item.iface + 'Routes'
        last_module = item.iface + 'Merge'
        gateway_mac_str = '{:X}'.format(gateway_mac)
        print('Adding route entry {}/{} for {}'.format(iprange, prefix_len,
                                                      route_module))

        print('Trying to retrieve neighbor entry {} from neighbor cache'.format(
            item.neighbor_ip))
        neighbor_exists = neighborcache.get(item.neighbor_ip)

        # How many gates does this module have?
        # If entry does not exist, then initialize it
        if not modgatecnt.get(route_module):
            modgatecnt[route_module] = 0

        # Compute likely index
        if neighbor_exists:
            # No need to create a new Update module
            gate_idx = neighbor_exists.gate_idx
        else:
            # Need to create a new Update module,
            # so get gate_idx from gate count
            gate_idx = modgatecnt[route_module]

        # Pause bess first
        bess.pause_all()
        # Pass routing entry to bessd's route module
        for _ in range(MAX_RETRIES):
            try:
                server.run_module_command(route_module, 'add',
                                          'IPLookupCommandAddArg', {
                                              'prefix': iprange,
                                              'prefix_len': int(prefix_len),
                                              'gate': gate_idx
                                          })
            except:
                print('Error adding route entry {}/{} in {}. Retrying in {}sec...'.
                      format(iprange, prefix_len, route_module, SLEEP_S))
                time.sleep(SLEEP_S)
            else:
                bess.resume_all()
                break
        else:
            bess.resume_all()
            print('BESS route entry ({}/{}) insertion failure in module {}'.format(
                iprange, prefix_len, route_module))
            return
            #raise Exception('BESS route entry ({}/{}) insertion failure in module {}'.
            #                format(iprange, prefix_len, route_module))

        if not neighbor_exists:
            print('Neighbor does not exist')
            # Create Update module
            update_module = route_module + 'DstMAC' + gateway_mac_str

            # Pause bess first
            bess.pause_all()
            for _ in range(MAX_RETRIES):
                try:
                    server.create_module('Update', update_module, {
                        'fields': [{
                            'offset': 0,
                            'size': 6,
                            'value': gateway_mac
                        }]
                    })
                except BESS.Error as e:
                    bess.resume_all()
                    if e.code == errno.EEXIST:
                        break
                    else:
                        return  #raise
                except Exception as e:
                    print(
                        'Error creating update module {}: {}. Retrying in {} secs...'
                        .format(update_module, e, SLEEP_S))
                    time.sleep(SLEEP_S)
                else:
                    bess.resume_all()
                    break
            else:
                bess.resume_all()
                print('BESS module {} creation failure.'.format(update_module))
                return  #raise Exception('BESS module {} creation failure.'.
                #        format(update_module))

            print('Update module created')

            # Connect Update module to route module
            link_modules(server, route_module, update_module, gate_idx, 0)

            # Connect Update module to dpdk_out module
            link_modules(server, update_module, last_module, 0, 0)

            # Add a new neighbor in neighbor cache
            neighborcache[item.neighbor_ip] = item

            # Add a record of the affliated gate id
            item.gate_idx = gate_idx

            # Set the mac str
            item.macstr = gateway_mac_str

            # Increment global gate count number
            modgatecnt[route_module] += 1

            neighbor_exists = item

        else:
            print('Neighbor already exists')

        # Finally increment route count
        neighborcache[item.neighbor_ip].route_count += 1


    def del_route_entry(server, item):
        iprange = item.iprange
        prefix_len = item.prefix_len
        route_module = item.iface + 'Routes'
        last_module = item.iface + 'Merge'

        neighbor_exists = neighborcache.get(item.neighbor_ip)
        if neighbor_exists:
            # Pause bess first
            bess.pause_all()
            # Delete routing entry from bessd's route module
            for i in range(MAX_RETRIES):
                try:
                    server.run_module_command(route_module, 'delete',
                                              'IPLookupCommandDeleteArg', {
                                                  'prefix': iprange,
                                                  'prefix_len': int(prefix_len)
                                              })
                except:
                    print(
                        'Error while deleting route entry for {}. Retrying in {} sec...'
                        .format(route_module, SLEEP_S))
                    time.sleep(SLEEP_S)
                else:
                    bess.resume_all()
                    break
            else:
                bess.resume_all()
                print('Route entry deletion failure.')
                return
                #raise Exception('Route entry deletion failure.')

            print('Route entry {}/{} deleted from {}'.format(
                iprange, prefix_len, route_module))

            # Decrementing route count for the registered neighbor
            neighbor_exists.route_count -= 1

            # If route count is 0, then delete the whole module
            if neighbor_exists.route_count == 0:
                update_module = route_module + 'DstMAC' + neighbor_exists.macstr
                # Pause bess first
                bess.pause_all()
                for i in range(MAX_RETRIES):
                    try:
                        server.destroy_module(update_module)
                    except:
                        print('Error destroying module {}. Retrying in {}sec...'.
                              format(update_module, SLEEP_S))
                        time.sleep(SLEEP_S)
                    else:
                        bess.resume_all()
                        break
                else:
                    bess.resume_all()
                    print('Module {} deletion failure.'.format(update_module))
                    return
                    #raise Exception('Module {} deletion failure.'.
                    #                format(update_module))

                print('Module {} destroyed'.format(update_module))

                # Delete entry from the neighbor cache
                del neighborcache[item.neighbor_ip]
                print('Deleting item from neighborcache')
                del neighbor_exists
            else:
                print('Route count for {}  decremented to {}'.format(
                    item.neighbor_ip, neighbor_exists.route_count))
                neighborcache[item.neighbor_ip] = neighbor_exists
        else:
            print('Neighbor {} does not exist'.format(item.neighbor_ip))


    def probe_addr(item, src_mac):
        # Store entry if entry does not exist in ARP cache
        arpcache[item.neighbor_ip] = item
        print('Adding entry {} in arp probe table'.format(item))

        # Probe ARP request by sending ping
        send_ping(item.neighbor_ip)

        # Probe ARP request
        ##send_arp(neighbor_ip, src_mac, item.iface)


    def parse_new_route(msg):
        item = NeighborEntry()
        # Fetch prefix_len
        item.prefix_len = msg['dst_len']
        # Default route
        if item.prefix_len is 0:
            item.iprange = '0.0.0.0'

        for att in msg['attrs']:
            if 'RTA_DST' in att:
                # Fetch IP range
                # ('RTA_DST', iprange)
                item.iprange = att[1]
            if 'RTA_GATEWAY' in att:
                # Fetch gateway MAC address
                # ('RTA_GATEWAY', neighbor_ip)
                item.neighbor_ip = att[1]
                _mac = fetch_mac(att[1])
                if not _mac:
                    gateway_mac = 0
                else:
                    #gateway_mac = mac2hex(_mac)
                    gateway_mac = mac2hex('22:53:7a:15:58:50')
            if 'RTA_OIF' in att:
                # Fetch interface name
                # ('RTA_OIF', iface)
                item.iface = ipdb.interfaces[int(att[1])].ifname

        if not item.iface in args.i or not item.iprange or not item.neighbor_ip:
            # Neighbor info is invalid
            del item
            return

        # if mac is 0, send ARP request
        if gateway_mac == 0:
            print('Adding entry {} in arp probe table'.format(item.iface))
            probe_addr(item, ipdb.interfaces[item.iface].address)

        else:  # if gateway_mac is set
            print('Linking module {}Routes with {}Merge (Dest MAC: {})'.format(
                item.iface, item.iface, _mac))

            link_route_module(bess, gateway_mac, item)


    def parse_new_neighbor(msg):
        for att in msg['attrs']:
            if 'NDA_DST' in att:
                # ('NDA_DST', neighbor_ip)
                neighbor_ip = att[1]
            if 'NDA_LLADDR' in att:
                # ('NDA_LLADDR', neighbor_mac)
                gateway_mac = att[1]

        item = arpcache.get(neighbor_ip)
        if item:
            print('Linking module {}Routes with {}Merge (Dest MAC: {})'.format(
                item.iface, item.iface, gateway_mac))

            # Add route entry, and add item in the registered neighbor cache
            link_route_module(bess, mac2hex(gateway_mac), item)

            # Remove entry from unresolved arp cache
            del arpcache[neighbor_ip]


    def parse_del_route(msg):
        item = NeighborEntry()
        for att in msg['attrs']:
            if 'RTA_DST' in att:
                # Fetch IP range
                # ('RTA_DST', iprange)
                item.iprange = att[1]
            if 'RTA_GATEWAY' in att:
                # Fetch gateway MAC address
                # ('RTA_GATEWAY', neighbor_ip)
                item.neighbor_ip = att[1]
            if 'RTA_OIF' in att:
                # Fetch interface name
                # ('RTA_OIF', iface)
                item.iface = ipdb.interfaces[int(att[1])].ifname

        if not item.iface in args.i or not item.iprange or not item.neighbor_ip:
            # Neighbor info is invalid
            del item
            return

        # Fetch prefix_len
        item.prefix_len = msg['dst_len']

        del_route_entry(bess, item)

        # Delete item
        del item


    def netlink_event_listener(ipdb, netlink_message, action):

        # If you get a netlink message, parse it
        msg = netlink_message

        if action == 'RTM_NEWROUTE':
            parse_new_route(msg)

        if action == 'RTM_NEWNEIGH':
            parse_new_neighbor(msg)

        if action == 'RTM_DELROUTE':
            parse_del_route(msg)


    def bootstrap_routes():
        routes = ipr.get_routes()
        for i in routes:
            if i['event'] == 'RTM_NEWROUTE':
                parse_new_route(i)


    def connect_bessd():
        print('Connecting to BESS daemon...'),
        # Connect to BESS (assuming host=localhost, port=10514 (default))
        for i in range(MAX_RETRIES):
            try:
                if not bess.is_connected():
                    bess.connect(grpc_url=args.ip + ':' + args.port)
            except BESS.RPCError:
                print(
                    'Error connecting to BESS daemon. Retrying in {}sec...'.format(
                        SLEEP_S))
                time.sleep(SLEEP_S)
            else:
                break
        else:
            raise Exception('BESS connection failure.')

        print('Done.')


    def reconfigure(number, frame):
        print('Received: {} Reloading routes'.format(number))
        # clear arpcache
        for ip in list(arpcache):
            item = arpcache.get(ip)
            del item
        arpcache.clear()
        for ip in list(neighborcache):
            item = neighborcache.get(ip)
            del item
        neighborcache.clear()
        for modname in list(modgatecnt):
            item = modgatecnt.get(modname)
            del item
        modgatecnt.clear()
        bootstrap_routes()
        signal.pause()


    def cleanup(number, frame):
        ipdb.unregister_callback(event_callback)
        print('Received: {} Exiting'.format(number))
        sys.exit()


    def main():
        global arpcache, neighborcache, modgatecnt, ipdb, event_callback, bess, ipr
        # for holding unresolved ARP queries
        arpcache = {}
        # for holding list of registered neighbors
        neighborcache = {}
        # for holding gate count per route module
        modgatecnt = {}
        # for interacting with kernel
        ipdb = IPDB()
        ipr = IPRoute()
        # for bess client
        bess = BESS()

        # connect to bessd
        connect_bessd()

        # program current routes
        bootstrap_routes()

        # listen for netlink events
        print('Registering netlink event listener callback...'),
        event_callback = ipdb.register_callback(netlink_event_listener)
        print('Done.')

        signal.signal(signal.SIGHUP, reconfigure)
        signal.signal(signal.SIGINT, cleanup)
        signal.signal(signal.SIGTERM, cleanup)
        signal.pause()


    if __name__ == '__main__':
        parser = argparse.ArgumentParser(
            description='Basic IPv4 Routing Controller')
        parser.add_argument('-i',
                            type=str,
                            nargs='+',
                            help='interface(s) to control')
        parser.add_argument('--ip',
                            type=str,
                            default='localhost',
                            help='BESSD address')
        parser.add_argument('--port', type=str, default='10514', help='BESSD port')

        # for holding command-line arguments
        global args
        args = parser.parse_args()

        if args.i:
            main()
        # if interface list is empty, print help menu and quit
        else:
            print(parser.print_help())
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: routes-setup
data: 
  routes_setup.sh: | 
    #!/usr/bin/env bash
    # SPDX-License-Identifier: Apache-2.0
    # Copyright(c) 2019 Intel Corporation

    #######
    ## Validated for clx2
    #######

    set -e
    set -x
    # TCP port of bess/web monitor
    gui_port_premium=8000
    bessd_port_premium=10514
    metrics_port_premium=8080

    gui_port_normal=8001
    bessd_port_normal=10515
    metrics_port_normal=8082

    # Driver options. Choose any one of the three
    #
    # "dpdk" set as default
    # "af_xdp" uses AF_XDP sockets via DPDK's vdev for pkt I/O. This version is non-zc version. ZC version still needs to be evaluated.
    # "af_packet" uses AF_PACKET sockets via DPDK's vdev for pkt I/O.
    # "sim" uses Source() modules to simulate traffic generation
    mode="dpdk"
    #mode="af_xdp"
    #mode="af_packet"
    #mode="sim"

    # Gateway interface(s)
    #
    # In the order of ("s1u" "sgi")
    ifaces=("ens1f0" "ens1f1")
    #ifaces=("access" "core")

    # Static IP addresses of gateway interface(s) in cidr format
    #
    # In the order of (s1u sgi)
    ipaddrs=(198.18.0.1/30 198.19.0.1/30)

    # MAC addresses of gateway interface(s)
    #
    # In the order of (s1u sgi)
    macaddrs_premium=(9e:b2:d3:34:ab:27 c2:9c:55:d4:8a:f6)
    macaddrs_normal=(be:b2:d3:34:ab:27 d2:9c:55:d4:8a:f6)

    # Static IP addresses of the neighbors of gateway interface(s)
    #
    # In the order of (n-s1u n-sgi)
    nhipaddrs=(198.18.0.2 198.19.0.2)

    # Static MAC addresses of the neighbors of gateway interface(s)
    # 
    # In the order of (n-s1u n-sgi)
    nhmacaddrs=(22:53:7a:15:58:50 22:53:7a:15:58:50)

    # IPv4 route table entries in cidr format per port
    #
    # In the order of ("{r-s1u}" "{r-sgi}")
    routes=("11.1.1.128/25" "0.0.0.0/0")

    num_ifaces=${#ifaces[@]}
    num_ipaddrs=${#ipaddrs[@]}

    # Set up static route and neighbor table entries of the SPGW
    function setup_trafficgen_routes() {
            for ((i = 0; i < num_ipaddrs; i++)); do
                    ip neighbor add "${nhipaddrs[$i]}" lladdr "${nhmacaddrs[$i]}" dev "${ifaces[$i % num_ifaces]}"
                    ip neighbor add "${nhipaddrs[$i]}" lladdr "${nhmacaddrs[$i]}" dev "${ifaces[$i % num_ifaces]}" || true
                    routelist=${routes[$i]}
                    for route in $routelist; do
                            ip route add "$route" via "${nhipaddrs[$i]}" metric 100
                            ip route add "$route" via "${nhipaddrs[$i]}" metric 100 || true
                    done
            done
    }

    # Assign IP address(es) of gateway interface(s) within the network namespace
    function setup_addrs() {
            for ((i = 0; i < num_ipaddrs; i++)); do
                    ip addr add "${ipaddrs[$i]}" dev "${ifaces[$i % $num_ifaces]}"
                    ip addr add "${ipaddrs[$i]}" dev "${ifaces[$i % $num_ifaces]}" || true
            done
    }

    # Set up mirror links to communicate with the kernel
    #
    # These vdev interfaces are used for ARP + ICMP updates.
    # ARP/ICMP requests are sent via the vdev interface to the kernel.
    # ARP/ICMP responses are captured and relayed out of the dpdk ports.
    function setup_mirror_links() {
        for ((i = 0; i < num_ifaces; i++)); do
                ip link add "${ifaces[$i]}" type veth peer name "${ifaces[$i]}"-vdev
                ip link set "${ifaces[$i]}" up
                ip link set "${ifaces[$i]}-vdev" up
                ip link set dev "${ifaces[$i]}" address "${macaddrs_normal[$i]}"
        done
        setup_addrs
    }

    # Set up interfaces in the network namespace. For non-"dpdk" mode(s)
    function move_ifaces() {
            for ((i = 0; i < num_ifaces; i++)); do
                    ip link set "${ifaces[$i]}" netns pause up
                    ip link set "${ifaces[$i]}" promisc off
                    ip link set "${ifaces[$i]}" xdp off
                    ip link set "${ifaces[$i]}" up
                    ip link set dev "${ifaces[$i]}" vf 0 mac "${macaddrs_premium[$i]}"
                    ip link set dev "${ifaces[$i]}" vf 1 mac "${macaddrs_normal[$i]}"
                    ip link set "${ifaces[$i]}" promisc on
                    ip link set "${ifaces[$i]}" xdp off
                    #if [ "$mode" == 'af_xdp' ]; then
                    #        sudo ip netns exec pause ethtool --features "${ifaces[$i]}" ntuple off
                    #        sudo ip netns exec pause ethtool --features "${ifaces[$i]}" ntuple on
                    #        sudo ip netns exec pause ethtool -N "${ifaces[$i]}" flow-type udp4 action 0
                    #        sudo ip netns exec pause ethtool -N "${ifaces[$i]}" flow-type tcp4 action 0
                    #        sudo ip netns exec pause ethtool -u "${ifaces[$i]}"
                    #fi
            done
            setup_addrs
    }
    
    case $mode in
    "dpdk" | "sim") setup_mirror_links ;;
    "af_xdp" | "af_packet")
            move_ifaces
            # Make sure that kernel does not send back icmp dest unreachable msg(s)
            #sudo ip netns exec pause iptables -I OUTPUT -p icmp --icmp-type port-unreachable -j DROP
            iptables -I OUTPUT -p icmp --icmp-type port-unreachable -j DROP
            ;;
    *) ;;

    esac

    # Setup trafficgen routes
    if [ "$mode" != 'sim' ]; then
            setup_trafficgen_routes
    fi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: upf
  labels:
    app: upf
spec:
  replicas: 1
  selector:
    matchLabels:
      app: upf
  template:
    metadata:
      labels:
        app: upf
      annotations:
        k8s.v1.cni.cncf.io/networks: default/sriov-dpdk-b2b-net1,default/sriov-dpdk-b2b-net2
    spec:
      shareProcessNamespace: true
      nodeSelector:
        kubernetes.io/hostname: clx2
      initContainers:
      # Currently CNI doesn't allow metric we're doing it here instead of net-attach-def
      - name: init-routes
        image: nfvri/upf-epc-8806-bess:0.3.0-dev
        env:
        - name: ENB_SUBNET
          value: '11.1.1.128/25'
        - name: S1U_GATEWAY
          value: '198.18.0.1'
        - name: SGI_GATEWAY
          value: '198.19.0.1'
        command: ["sh", "-xec"]
        args:
        - /conf/routes_setup.sh
        # - ip route add $ENB_SUBNET via $S1U_GATEWAY;
        #   ip route add default via $SGI_GATEWAY metric 110;
        securityContext:
          privileged: true
          capabilities:
            add:
              - NET_ADMIN
        volumeMounts:
        - name: routes-setup
          mountPath: /conf
      # Reqd. if working with AF_PACKET so that kernel does not reply to GTP-U packets
      #- name: iptables
      #  image: omecproject/upf-epc-bess:master-latest
      #  command: [ "sh", "-xec"]
      #  args:
      #  - iptables -I OUTPUT -p icmp --icmp-type port-unreachable -j DROP;
      #  securityContext:
      #    capabilities:
      #      add:
      #        - NET_ADMIN
      containers:
      - name: routectl
        image: nfvri/upf-epc-8806-bess:0.3.0-dev
        command: ["/conf/route_control_normal.py"]
        args:
        - --port 10514
        - -i
        - ens1f0
        - ens1f1
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        resources:
          limits:
            cpu: 256m
            memory: 128Mi
        volumeMounts:
        - name: upf-conf
          mountPath: /conf
      - name: bessd
        image: nfvri/upf-epc-8806-bess:0.3.0-dev
        stdin: true
        tty: true
        args:
        - -grpc-url=0.0.0.0:10514
        env:
        - name: CONF_FILE
          value: /conf/upf.json
        livenessProbe:
          tcpSocket:
            port: 10514
          initialDelaySeconds: 30
          periodSeconds: 20
        lifecycle:
          postStart:
            exec:
              command: ["sh", "-c", "until ss | grep -q 10514; do sleep 5; echo waiting for bessd; done; ./bessctl run up4;"]
        securityContext:
          capabilities:
            add:
            - IPC_LOCK # AF_PACKET vdev (and 4K pages) uses mmap
        resources:
          requests:
            cpu: '2'
            memory: 256Mi
            hugepages-1Gi: 2Gi
            intel.com/intel_sriov_dpdk_b2b_net1: '1'
            intel.com/intel_sriov_dpdk_b2b_net2: '1'
          limits:
            hugepages-1Gi: 2Gi
            cpu: '2'
            memory: 256Mi
            intel.com/intel_sriov_dpdk_b2b_net1: '1'
            intel.com/intel_sriov_dpdk_b2b_net2: '1'
        volumeMounts:
        - name: upf-conf
          mountPath: /conf
        - name: hugepages
          mountPath: /dev/hugepages
      - name: web
        image: upf-epc-8806-bess:0.3.0-dev
        command: ["bessctl"]
        args:
        - daemon disconnect -- daemon connect localhost:10514 -- http 0.0.0.0 8001
        resources:
          limits:
            cpu: 256m
            memory: 128Mi
      - name: pfcpiface
        image: nfvri/upf-epc-8806-pfcpiface:0.3.0-dev
        command: ["pfcpiface"]
        args:
        - -config
        - /conf/upf.json
        - -bess localhost:10514 
        - -http 0.0.0.0:8082
        volumeMounts:
        - name: upf-conf
          mountPath: /conf
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        resources:
          limits:
            cpu: 256m
            memory: 128Mi
      volumes:
      - name: upf-conf
        configMap:
          name: upf-conf
          defaultMode: 0777
      - name: hugepages
        emptyDir:
          medium: HugePages
      - name: routes-setup
        configMap:
          name: routes-setup
          defaultMode: 0777
        

